DONE
    
    Add tests for typical challenge token exploits.

    To do this I will need to be able to create a modified version of the client
    that gets the challenge token and then saves it off, so it can be stored
    and then reused by another client with a different address.

    Attacks to protect against are:

    reuse of the same challenge token, from a different client address (impersonation)

    reuse of the same challenge token, on a different server (going wide and trying to join servers)

    using an expired challenge token

    getting through with an invalid challenge token.

    It's really difficult to see how I can keep the client/server code clean in Yojimbo,
    while still provide enough flexibility to override behavior and test these cases above.

    Need to think about this for a while!  

    It seems that the least disruptive way to handle this is for the derived client and server
    to be able to access data members of the parent class, so it can be inspected, modified
    and messed with, allowing the derived classes to read data and changed behavior.

    Two key pieces of tech are needed:

    1. a client needs to try to connect, stash the challenge token when it receives it, and stop connect (without clearing connect token)

    2. a client needs to be *forced* into a connection challenge response state with a specified server address and challenge token

    3. a way for the server to construct an older challenge token, eg. with an already expired timestamp

    If I can implement these, I should be able to implement all the tests required for challenge token.

    Made data members in yojimbo client/server protected rather than private.

TODO

    Implement client connect, stash token and abort.

    Add accessor to grab challenge token.

    Add function "ForceIntoConnectionChallengeResponse" that takes challenge token, server address etc.

    ^---- this should be called after faking the same connect with all the same client connect data (from the original client)

    Implement way to override construction of the challenge token so it has an early expiry, or a complete
    overriden version of the function that generates the challenge token, and then makes a modification to it
    before returning it?

    ---------------

    Verify that packets sent over the network once client/server are connected have valid sequence #s and these sequence #s 
    are not always zero (make sure proper sequence #s are used)

    Make sure that encrypted packet packets can't get through if they are sent unencrypted. V.important obviously.

    ---------------

    Extend the packet factory so additional packet types above the client/server packet set can be sent and received.

    This needs to be tested, and easy to do, as this is the common situation, extend the client/server
    packet types with your own that must be processed.

    What needs to be done to client and server classes so they can let derived classes handle custom packet types?

    -------------------

    Design in the concept of both secure and insecure connects at the same time.

    Eg. should be secure by default, but the server can be opened up into insecure mode.

    In this mode, packets that are normally encrypted are globally allowed to be received unencrypted.

    When the client connects insecure mode, all packets are sent insecure. No safety here.

    Server allows insecure connections, eg. direct to slot without challenge token.

    -------------------

    Also make the heartbeat only get sent if a packet hasn't been sent for heartbeat rate...

    Don't send them redundantly when other packets are being fired across. Same for client -> server.

    Make sure that received packets, even unknown ones per-the base class let the timeout reset on receive.

    -------------------

    Need to implement packet aggregation and fragmentation and reassembly as well inside the socket interface,
    but by composition using base classes so this functionality can easily be reimplemented for other interfaces,
    eg. a network interface implementation that goes over boost asio instead of BSD sockets for example.

    -------------------

    Possibly implement open/close support for the server.

    Implement a disconnect all clients function.

    If closed while players are connected, disconnect all clients.

    Perhaps open could accept max # of clients?

    -------------------

    Bring across the reliable ordered event system and large block sender.

    Store this reliability level system inside the client/server, have one of these endpoints per-client slot.

    -------------------
