DONE

    Now implement the server-side processing of the insecure packet. Basically, take that packet, find a
    free client slot and immediately accept or deny.

    What to do if the client is already connected?

    I think the insecure connect needs a salt.

    If the same address is connected but with a different salt, ignore the connect.

    No need to do the challenge response tho. That's for security and we don't need that here.

    Add insecure connect state.

    Add salt to the insecure connect packet.

    Idea: Instead of adding salt, make the client id a random number, and then stash per-client an insecure flag.

    Why not add a concept of client flags, eg. uint32_t clientFlags[MaxClients]?

    Or, make insecure clients have a client id of 0 and use the salt?

    It's difficult to say what is best.

    On one hand, a random 64bit number is extremely unlikely to collide.

    On the other, what value is a client id anyway, if it is a random number for fake clients? Why not just make it zero with salt?

    What if somebody during testing wanted to connect a client with a *known* client id, but insecurely. 

    Complicated. What exactly is the use case for insecure connect?

    For the moment, assume that insecure connect just won't establish a valid client id, eg. client id will be zero

    Removed client id from connect function. Not used.

    Implement client "InsecureConnect" that takes just the address, and goes into insecure connect state.

    Generate a random salt on each call to insecure connect.

    Make sure all this is wrapped with #if YOJIMBO_INSECURE_CONNECT

    Get it to the point where the client sends the insecure connect packets w. the salt

TODO

    -------------------

    Next on the server side process the insecure connect packets

    On the secure, and insecure connect, test if somebody is already connected with the same client id. If already connected, deny immediately. *ALREADY CONNECTED*

    Look for a matching client slot with the address and salt.

    If the address and salt match, reply with a heartbeat.

    Otherwise, if the address does not exist, add it, reply with heartbeat.

    If the address exists, but the salt is different, deny the connection request.

    -------------------

    Now on the client take the heartbeat and go direct from insecure connect to connected if it's received.

    -------------------

    Don't send the heartbeat packet if other packets have been sent recently, eg. don't send if redundant.

    -------------------

    Make sure to do this *only* once the connection has been established. You don't want to miss the first
    game packet sent through (discard) because you are not connected. eg. keep sending heartbeats until
    fully connected on that side, even if other packets are sent.

    -------------------

    Need to implement packet aggregation and fragmentation and reassembly as well inside the socket interface,
    but by composition using base classes so this functionality can easily be reimplemented for other interfaces,
    eg. a network interface implementation that goes over boost asio instead of BSD sockets for example.

    Also in the simulator. The simulator should have the same aggregation behavior.

    -------------------

    Bring across the reliable ordered event system and large block sender.

    Store this reliability level system inside the client/server, have one of these endpoints per-client slot.

    -------------------

    It's annoying that the network interface has to:

    a) manually enable encryption and disable encryption for connection request packet type

    b) clear send and recv queues manually in destructor

    -------------------

    Need to clean up the simulator and create a network interface around the simulator (or implement that interface directly...)

    This is important for tests because even over loopback occasionally packets don't get through (due to thread race)
    which is breaking my functional tests 1/10 runs or so.

    -------------------
