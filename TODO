DONE    

    Support for different client/server implementations

    Client/server implementation built on top of reliable.io and netcode.io

    Packet fragmentation and re-assembly support from reliable.io

    Better implementation of connect tokens via netcode.io

    Port across secure_server to new API.

TODO

    Track down message leaks in receive queue overflow.

        ^--- Only clue is that this weirdness requires block messages to repro. It's a logic error or memory trash somewhere?!

        ^--- Yeah. There is definitely a memory trash that is happening as a result of block messages. Stuff doesn't make sense.`

    There is the following weird behavior:

        1. With a mix of blocks and non-blocks, it leaks messages

        2. With blocks only (even if blocks have block size only 10, it hangs!)

    What the fuck?!

    OK. The hang is just the logical continuation of the thing where it doesn't exit out

    This is to be expected, because block messages are processed only one at a time, therefore they cannot have the problem of the receive queue overflowing.

    So #2 is not a bug, as designed.

    So why do we get message leaks when there is a combination of messages and blocks?

    Need to think about this. This is the clue. There is definitely something going on here.

    The question I think is, is it leaking a block message or a regular message? This could help determine what is going on.








    ----------------

    Bring across golang web server implementation, but so that it uses the golang netcode.io library in Docker, vs. coding it manually.

    Make sure the golang web server implementation doesn't leak memory (for example, it needs to be updated with the close wrapper).

    Bring across the C++ matcher implementation again, and upgrade it to use the new connect tokens from netcode.io

    Port across secure_client to new API.

    Bring across packet loss, latency, jitter estimates from reliable.io

    Congestion adoidance in reliable.io (if reasonably possible given that user is in control of packet sizes...)

    Unreliable, ordered channel in yojimbo. Simply keep track of the most recently received message id, and discard any messages older than that.

    Extend soak test to have unreliable, unordered channel, and to make sure it exercises packet fragmentation and reassembly codepath.

    Extend yojimbo to have detailed logging support, eg. log levels (none, error, info, debug), as well as different modules that can have logging enabled/disabled.

    Extend netcode.io so it can have an overriden logging callback function.

    Extend reliable.io so it can have an overriden assert callback function.

    Extend netcode.io so the user can set a custom allocator to use for client and server allocations.

    Extend reliable.io so the user can set a custom allocator to use for endpoints.

    Integrate custom allocators for netcode.io and reliable.io with client and server allocators in yojimbo.

    Extend netcode.io and reliable.io to minimize packet copying, eg. assume packet is prefixed with available padding in front for headers.

