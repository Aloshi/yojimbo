DONE

    Server compiles and runs on linux but obviously its hardcoded address is wrong...

    Need a way to get the address of a network interface after the fact

    And then that address can be automatically passed to the server, so it knows its address.

    No need for "SetServerAddress" anymore, but leave it in in case the user wants to override.

    Update. You can't query the local IP address from a socket. Instead you need to walk the set of
    network interfaces using platform specific APIs, and then you can bind a socket to 0.0.0.0 *or*
    bind it to a specific IP address in that list of interface IP addresses.

    Windows:

        GetAdaptersInfo()
        GetAdaptersAddresses()

    MacOSX:

        ?

    Linux:

        getifaddrs

    More info: http://linux.die.net/man/2/bind

    Seems that I need to extend network interfaces so they can be bound to a specific IP address.

    If you have multiple network interfaces, especially for dedicated servers, you're going to only
    want the packets sent to particular IP (eg. the interface you are running your dedi on)

    Since localhost connections are going to be, by definition, insecure... as long as non-secure
    connections work to the localhost it's fine. Don't sweat too much the whole ::1 vs. 127.0.0.1 vs
    real IP thing that sometimes happens.

    Added a bunch of functions, eg. get network interface info. get first IPv4 address, get first IPv6
    address...

TODO


    -------------------
    
    Setup the client so it can accept an IP address or port on the command line.

    Run the server on my linux box and verify I can connect to it from my macbook.

    -------------------

    Make sure both the client and server can compile and run on Windows.

    eg. Need to implement platform_* functions for windows. I must have implementations somewhere.

    Verify cross connects, eg. windows -> mac client, mac -> windows connect. both -> linux.

    -------------------

    Clean up the simulator and create a network interface around the simulator (or implement that interface directly...)

    This is important for tests because even over loopback occasionally packets don't get through (due to thread race)
    which is breaking my functional tests 1/10 runs or so.

    The simulator needs to *back* an interface, eg. a network simulator is created, and a simulator interface works on top of it.

    Move the tests over to use network simulator interfaces instead of sockets.

    Verify that the tests can run in soak mode, eg. reps and don't break. 

    Make sure all tests pass with ridiculous packet loss as well (90%). Probably need to extend the # of iterations...

    -------------------

    Need to implement packet aggregation and fragmentation and reassembly as well inside the socket interface,
    but by composition using base classes so this functionality can easily be reimplemented for other interfaces,
    eg. a network interface implementation that goes over boost asio instead of BSD sockets for example.

    Also in the simulator. The simulator should have the same aggregation behavior.

    -------------------

    Bring across the reliable ordered event system and large block sender.

    Store this reliability level system inside the client/server, have one of these endpoints per-client slot.

    Consider how the ack system is going to integrate. Custom ack header with bits and so on per-packet? (aggregate packet header?)

    Acks on a message id level instead of acks on a packet level? Who knows. A packet id that increases for each *message*
    packet sent, with packet header just for that packet type? Sure. This is it. This way I don't need to send message
    packets unless there are actually messages to be sent.

    The whole message packet system can be self contained with no bullshit. Awesome. 

    Combine the ack system and the message packet into one system!

    -------------------