DONE

    Now implement the server-side processing of the insecure packet. Basically, take that packet, find a
    free client slot and immediately accept or deny.

    What to do if the client is already connected?

    I think the insecure connect needs a salt.

    If the same address is connected but with a different salt, ignore the connect.

    No need to do the challenge response tho. That's for security and we don't need that here.

TODO

    Add salt to the insecure connect packet.

    Add insecure connect state.

    Implement client "InsecureConnect" that takes just the address, and goes into insecure connect state.

    Generate a random salt on each call to insecure connect.

    Make sure all this is wrapped with #if YOJIMBO_INSECURE_CONNECT

    Get it to the point where it sends the insecure connect packets, and then if it gets a heartbeat back
    it goes into fully connected mode.

    -------------------

    Next on the server side process the insecure connect packets

    Look for a matching client slot with the address and salt.

    If the address and salt match, reply with a heartbeat.

    Otherwise, if the address does not exist, add it, reply with heartbeat.

    If the address exists, but the salt is different, deny the connection request.

    -------------------

    Don't send the heartbeat packet if other packets have been sent recently, eg. don't send if redundant.

    Make sure to do this *only* once the connection has been established. You don't want to miss the first
    game packet sent through (discard) because you are not connected. eg. keep sending heartbeats until
    fully connected on that side, even if other packets are sent.

    -------------------

    Need to implement packet aggregation and fragmentation and reassembly as well inside the socket interface,
    but by composition using base classes so this functionality can easily be reimplemented for other interfaces,
    eg. a network interface implementation that goes over boost asio instead of BSD sockets for example.

    Also in the simulator. The simulator should have the same aggregation behavior.

    -------------------

    Bring across the reliable ordered event system and large block sender.

    Store this reliability level system inside the client/server, have one of these endpoints per-client slot.

    -------------------

    It's annoying that the network interface has to:

    a) manually enable encryption and disable encryption for connection request packet type

    b) clear send and recv queues manually in destructor

    -------------------

    Need to clean up the simulator and create a network interface around the simulator (or implement that interface directly...)

    This is important for tests because even over loopback occasionally packets don't get through (due to thread race)
    which is breaking my functional tests 1/10 runs or so.

    -------------------
