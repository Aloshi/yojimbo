DONE


TODO

    Wrap it up. Make sure everything works on Windows, Mac and Linux.

    -------------------

    Porting back some fixes to protocol2.

    Fix the overlapping buffers trash on linux.

    Fix the bad logic on client side disconnect.

    Fix the packet leak.

    -------------------
















    -------------------

    Now extend the packet factory as well, and include additional packet types above the client/server packet set.

    This needs to be tested, and easy to do, as this is the common situation, extend the client/server
    packet types with your own that must be processed.

    What needs to be done to client and server classes so they can let derived classes handle custom packet types?

    -------------------

    When the server needs to flush to a client (who is disconnected, and will lose encryption mapping shortly),
    it will also be necessary to send packets to that client immediately.

    However, you only want to flush packets sent to that address immediately, not all addresses.

    So the send queue really needs to be more like a ring-buffer, with the ability to have holes,
    eg. packets that have been sent ahead of time.

    We're going to need this as well for packets sent to a particular client, we need to aggregate
    all encrypted packets together into one packet, then all unencrypted packets -- so the ability
    to walk over the send queue and inspect packets and remove packets from that queue out of order
    is necessary.

    -------------------

    Need to design in the concept of both secure and insecure connects at the same time.

    Eg. should be secure by default, but the server can be opened up into insecure mode.

    In this mode, packets that are normally encrypted are globally allowed to be received unencrypted.

    When the client connects insecure mode, all packets are sent insecure. No safety here.

    Server allows insecure connections, eg. direct to slot without challenge token.

    -------------------

    Also make the heartbeat only get sent if a packet hasn't been sent for heartbeat rate...

    Don't send them redundantly when other packets are being fired across. Same for client -> server.

    Make sure that received packets, even unknown ones per-the base class let the timeout reset on receive.

    -------------------
    
    Up next, yojimbo_encryption_mapping.h/cpp?

    I think so. Derived from client/server expiring constant time structure?

    Must be dynamically allocated, don't use the stupid allocator, move away from it.

    -------------------

    Bring back the "pm loc" counter.

    -------------------
    
    Idea: maybe a flag on send packet, "immediate"?

    eg. as an alternative to complicated queue rewrite with packets being sent out of order, eg. flush all for this address.

    Just send some packets and marke their sends as *immediate*, = no queue, serialize this and send it right away.

    Sounds good.

    -------------------