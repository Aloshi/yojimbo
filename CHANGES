
Tuesday 31st May, 2016
======================

    Idea: maybe a flag on send packet, "immediate"?

    eg. as an alternative to complicated queue rewrite with packets being sent out of order, eg. flush all for this address.

    Just send some packets and marke their sends as *immediate*, = no queue, serialize this and send it right away.

    Sounds like a good feature to add.

    Found some bugs in the client/server connection. They were not increasing the sequence number for client/server packets on sends.

    This means they were not encrypting with nonce, hence the code was broken from a security point of view. Fixed.

    This fix should be brought across to the open source example source code for the article series.

    Added the interface, now need to restructure the socket interface to be able to write and send a single packet at a time when necessary.

    Done works well.

    It's annoying that the server when procesing a client side disconnect sends a disconnect packet to the client that has already disconnected.

    So I extended DisconnectClient to take a bool parameter, true by default, to send a disconnect packet to the client.

    And then I pass false into DisconnectClient for timeouts and when processing a disconnect packet sent from that client, because it is redundant.

    Make the same change vice versa for the client, so if a server-side connect happens, or the client times out, the client does not send a redundant 
    disconnect packet to the server.


Sunday 29th May, 2016
=====================

    Convert protocol2.h

    Convert network2.h

    Split out parts of yojimbo_protocol.h / network.h to other files

    Especially, generally useful functions into yojimbo_util.h or yojimbo_common.h

    I like yojimbo_common.h better. Fuck util.

    Finish conversion of yojimbo_common.h inlines into yojimbo_common.cpp

    Move bitpacker into yojimbo_bitpack.h

    Move stream into yojimbo_stream.h

    Move serialization functions into yojimbo_serialize.h

    Now repurpose yojimbo_protocol.h into yojimbo_packet.h - packet header, packet class, packet factory, read/write packet functions.

    Split up network into multiple headers.

    yojimbo_network.h is good for address and sockets. Great. Leave that.

    Move the network simulator out to yojimbo_network_simulator.h

    Remove InitCrypto, instead put it inside InitializeYojimbo / ShutdownYojimbo instead.

    Move the token stuff into yojimbo_client_server.h

    Unit test the token stuff (based on 008 starter...)

    Remove the testing harness stuff from client_server.cpp

    Move the rest of the client/server stuff into yojimbo_client_server.h/cpp

    Eventually, going to want to make a bunch of this stuff more *configurable*

    eg. let the server restrict the number of clients he wants to allow to connect.

    even though the maximum of 64 is enforced statically at compile time...

    But for now, keep it static, and focus on implementing enough callbacks to extend the base class.

    eg. you extend the client/server to create your own versions, and demonstrate this by adding
    new packet types, implementing all client/server logs I want via callbacks (not the base class)
    etc.

    Inherited custom GameClient and GameServer classes from base client and server.

    Did the same for GameNetworkInterface and GamePacketFactory.

    There seems to be some sort of weirdness with the disconnect packet set from client -> server?

    Ah. There was a packet leak if the packet failed to decrypt (eg. broken encryption mapping)

    Look for interesting counters to add on the server, eg. a counter for each invisible thing that could happen,
    but indicates something maybe going wrong, eg. connect token reject etc.

    Done. A bunch of counters. Will be more.

    Comment out logs that don't make sense to become callbacks.

    Commented out logs that I might want to bring back (#if CLIENT_SERVER_DEBUG_LOGS or something)

    Add callbacks for packets sent on server (by type)

    Unified all packet send to go through one function, don't directly call on the interface (keep it internal)

    Implement logs so I can see the traffic going back and forth for debugging. Works well!

    Now implement callbacks for packet receive on server.

    Same treatment for client:

    1. Replace logs with callbacks where possible 

    2. Callback for state changes

    3. Add callback for packet send

    4. Add callback for packet receive

    Verify logs are now acceptable. Yes.

    Just need to add client state names, and it's all good.
