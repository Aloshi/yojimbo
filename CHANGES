
Monday June 6th, 2016
=====================

    test client can't connect because full (eg. connect 4/4 clients, try to connect another...)

    test was incorrect because it tried to call "connect" again on an already connected client,
    with the same token.

    should this be supported? not really. each connect requires a new token.

    It's a fact however that you can kick off an undefined reconnect with the same token
    already grabbed, but that connect will risk having a client join into an state that is
    undefined, eg. the client will have to indicate to the server that it wants to start again
    from the lowest defined state, eg. build up from state 0.

    So it could be supported at the high level if necessary.

    It may also have some implications on reliable ordered events though, so perhaps it's
    *not* worth supporting.

    Added test for detecting connect token reuse.

    Added test for client connect token expiry.

    Added test for server address being in connect token whitelist.

    Added test for client connect token being invalid (random data).


Sunday June 5th, 2016
=====================

    Added test for client reconnect 

    Added tests for client side disconnect and server side disconnect

    Renamed "IsConnected" functions in the server to "FindClientId" and "FindAddressAndClientId"
    because it had already created a bug where I thought "IsConnected" meant "IsConnected( int clientIndex )"

    Added code to check client slots and iterate across only up to m_maxClients rather than MaxClients

    This allows the server start to spocify a max clients less than MaxClients (64), which would 
    allow for a subclassed server to restrict allocation of expensive per-client data to smaller
    client counts on start/stop life cycle.

    Extended OnStart so it accepts int maxClients to make stuff easy for allocation on start.

    Made sure OnStart and OnStop are called (they weren't...)

    Added tests for client and server-side timeout after connection established


Saturday June 4th, 2016
=======================

    added tests:

        1. client connect

        2. client connection request timeout

    extended client/server to have start/stop concept.

    Most importantly, start allows you to specify the # of clients you want.

    Added a bunch of checks "assert( IsRunning() )" where appropriate in server.

    Now get test working with new start as well.

    Standardized passing in time in first parameter to function in client/server (public) where required.

    I like keeping time separate because you'll probably wrap the client/server with your own struct or class,
    and probably have separate global concepts of time. The client/server don't OWN time. You want the time
    somewhere up above and passed in.

    Add callbacks for OnStart and OnStop

    Added time to all callbacks because if you want it, how else will you get it?!

    OK. The time thing is annoying. Adding cached copy of time in client/server.

    "AdvanceTime" function sets it. You must advance time!

    This cleans up stuff nicely. I think I want this in the network interface as well. It's annoying to pass in time redundantly.

    Yes. Adjusted client interface as well and everything has cleared up nicely.


Tuesday 31st May, 2016
======================

    Idea: maybe a flag on send packet, "immediate"?

    eg. as an alternative to complicated queue rewrite with packets being sent out of order, eg. flush all for this address.

    Just send some packets and marke their sends as *immediate*, = no queue, serialize this and send it right away.

    Sounds like a good feature to add.

    Found some bugs in the client/server connection. They were not increasing the sequence number for client/server packets on sends.

    This means they were not encrypting with nonce, hence the code was broken from a security point of view. Fixed.

    This fix should be brought across to the open source example source code for the article series.

    Added the interface, now need to restructure the socket interface to be able to write and send a single packet at a time when necessary.

    Done works well.

    It's annoying that the server when procesing a client side disconnect sends a disconnect packet to the client that has already disconnected.

    So I extended DisconnectClient to take a bool parameter, true by default, to send a disconnect packet to the client.

    And then I pass false into DisconnectClient for timeouts and when processing a disconnect packet sent from that client, because it is redundant.

    Make the same change vice versa for the client, so if a server-side connect happens, or the client times out, the client does not send a redundant 
    disconnect packet to the server.

    Implement encryption manager.

    Hook up the socket interface to use it.

    It needs time passed in to do timeouts for encryption mappings, so extended send/receive packets to take time parameters.

    (This will come in super handy when implementing a network interface wrapper around the network simulator)

    Start with something simple that is O(n) but hot/cold split so it is reasonably efficient, eg. array with holes and max.

    Consider. How does the encryption mapping deal with connection requests that setup an encryption mapping
    but don't complete all the way to connect. Do encryption mappings have timeouts? eg. 10 seconds?

    Each time a packet is sent or received on the encryption mapping, the encryption mapping is updated
    so the MRU time is the current time.

    Then if an encryption mapping is old, or if we are looking for an empty encryption mapping slot, the old slots
    are thrown out and reused automatically, which should fill holes. Works well.

    Implement a basic timeout, eg. if an entry is older than 15 seconds, it will be reused for another address.

    Now need to implement encryption mapping remove.

    The only tricky part of this is that it has to be smart enough when it is the last entry
    to search to the left and find the next valid entry which has not already expired (time).

    This means that remove encryption mapping also needs time passed in.

    Extended interface to add this.

    Now to implement the function. Do it.

    Verify basic client/server test still passes.

    All good.


Sunday 29th May, 2016
=====================

    Convert protocol2.h

    Convert network2.h

    Split out parts of yojimbo_protocol.h / network.h to other files

    Especially, generally useful functions into yojimbo_util.h or yojimbo_common.h

    I like yojimbo_common.h better. Fuck util.

    Finish conversion of yojimbo_common.h inlines into yojimbo_common.cpp

    Move bitpacker into yojimbo_bitpack.h

    Move stream into yojimbo_stream.h

    Move serialization functions into yojimbo_serialize.h

    Now repurpose yojimbo_protocol.h into yojimbo_packet.h - packet header, packet class, packet factory, read/write packet functions.

    Split up network into multiple headers.

    yojimbo_network.h is good for address and sockets. Great. Leave that.

    Move the network simulator out to yojimbo_network_simulator.h

    Remove InitCrypto, instead put it inside InitializeYojimbo / ShutdownYojimbo instead.

    Move the token stuff into yojimbo_client_server.h

    Unit test the token stuff (based on 008 starter...)

    Remove the testing harness stuff from client_server.cpp

    Move the rest of the client/server stuff into yojimbo_client_server.h/cpp

    Eventually, going to want to make a bunch of this stuff more *configurable*

    eg. let the server restrict the number of clients he wants to allow to connect.

    even though the maximum of 64 is enforced statically at compile time...

    But for now, keep it static, and focus on implementing enough callbacks to extend the base class.

    eg. you extend the client/server to create your own versions, and demonstrate this by adding
    new packet types, implementing all client/server logs I want via callbacks (not the base class)
    etc.

    Inherited custom GameClient and GameServer classes from base client and server.

    Did the same for GameNetworkInterface and GamePacketFactory.

    There seems to be some sort of weirdness with the disconnect packet set from client -> server?

    Ah. There was a packet leak if the packet failed to decrypt (eg. broken encryption mapping)

    Look for interesting counters to add on the server, eg. a counter for each invisible thing that could happen,
    but indicates something maybe going wrong, eg. connect token reject etc.

    Done. A bunch of counters. Will be more.

    Comment out logs that don't make sense to become callbacks.

    Commented out logs that I might want to bring back (#if CLIENT_SERVER_DEBUG_LOGS or something)

    Add callbacks for packets sent on server (by type)

    Unified all packet send to go through one function, don't directly call on the interface (keep it internal)

    Implement logs so I can see the traffic going back and forth for debugging. Works well!

    Now implement callbacks for packet receive on server.

    Same treatment for client:

    1. Replace logs with callbacks where possible 

    2. Callback for state changes

    3. Add callback for packet send

    4. Add callback for packet receive

    Verify logs are now acceptable. Yes.

    Just need to add client state names, and it's all good.
