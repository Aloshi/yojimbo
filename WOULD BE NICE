WOULD BE NICE

    ------------------

    Does a similar attack existing with challenge responses?

    Yes. You could compose any encrypted packet type, and store a valid encrypted packet, and replay that as an attack, and potentially spam millions of the same packets over and over in an attempt to flood the server.

    But it would only work for that one particular connected client, and for packets spoofed fram that address.

    So the attack possible would be to connect a client, and then send lots of replays of the same packet sequence #

    In this case, it might be possible to detect lots of spammed packets coming in (duplicates of packets)...

    Also, it might be possible to put the sequence # as part of the additional data in AEAD, so it can't be modified without breaking the packet.

    Then, implement some code to quickly filter out any sequence numbers older than current sequence minus some amount, like 1024.

    Then implement a sequence buffer with uint64_t sequence numbers, and if a packet has already been received (according to 64 bit sequence number), or if it is older than the current sequence # minus 1024, discard it (without decryptiong it...)

    I can do this because the nonce (the sequence) is implicitly secure. Change the value, and the data won't decrypt.

    This will fix this attack. Nice!

    ------------------

    Should have a unit test to verify a client cannot connect with same address, and that this does not disturb the existing connected client

    ------------------

    Should have a unit test to verify that a client cannot connect with the same client id (but a different connect token)

    ------------------

    Default allocator should store block size in 4 bytes preceding the allocated block

    This way the default allocator can report on # of bytes allocated.

    Right now it cannot.

    ------------------
    
    Add a test for a very large message send queue (and large # of messages per-packet) with a tiny message receive queue.
    
    This would make sure we never send messages that the reciever can't buffer. Right now it's possible for all the unit tests 
    to pass, even if the code under stress will send messages that the reciever can't buffer.

    ------------------

    Would really like a nice way in debug builds to warn the user about stuff, eg. better than an assert, an assert with a message.

    For example, a lot of asserts seem really low level, but they just mean, OK, you added your own packet types, but forgot to override the callback "CreatePacketFactory".

    The last thing I want is a user experiencing a bunch of really obscure low-level asserts when they are just trying to use the library.

    So there should be this idea of checks which print out a nice error message, hey, you didn't do a thing.

    Ideally, when working with a client integrating this library, find whatever pain points they experience on first integration, and then add checks to guard against these and save time for the next client.
    
    ------------------

    Definitely need more usage documentation and samples showing how to do stuff.

    I don't know that it's immediately obvious how to use libyojimbo from the samples. Or, what exactly libyojimbo does or what it's for?

    Also, better documentation could be added explaining what yojimbo is for (dedicated servers), and how its protocol works.

    Perhaps a bunch of posts to gafferongames.com would be a good idea to start?

    ------------------

    Add tests to make sure the client can recover and reconnect after one of the error states below. eg. error is properly cleared.

        CLIENT_STATE_PACKET_FACTORY_ERROR
        CLIENT_STATE_MESSAGE_FACTORY_ERROR
        CLIENT_STATE_STREAM_ALLOCATOR_ERROR

    ------------------

    Add a unit test that actually exercises the stream allocator.

    ------------------

    Add a unit test that intentionally exhausts the stream allocator.

    ------------------

    ^---- To solve this, provide a callback on connection request deny, challenge response denied, so the user can print out a callback, then print that out in shared.h but only if not in logging mode (unit tests).

    ------------------
    
    Add a test case for both unordered and ordered messages to show that it properly handles a message failing to serialize, 

    eg. properly cleans up, sets error state, shuts down the connection.

    Previously, a bug snuck through where messages were not getting cleaned up properly and the server would crash in this situation.

    Adding these tests will make sure this never happens again.

    ------------------

    Would be nice if a secure client connect accepted a list of servers to try to connect to, instead of having the user need to do that iteration manually, outside the client class. This is how it is meant to be used, after all.

    ------------------

    Really need to make the matcher HTTPS request asynchronous, can't have it blocking the main thread like it does now!

    ------------------

    Need to get coverity setup to run with a travis job. Right now, it needs to be run manually, by somebody.

    It should be setup to run automatically on each commit to "coverity" branch, then I can create a premake action to determine current branch, mainline or development, and integrate across current head to that branch.

    eg. pm coverity

    ------------------

    You should be able to put a network simulator in front of a real BSD socket transport, so bad network conditions can be simulated on top of a real socket.

    ------------------